conv.pts <- seq(min, max, step)
l <- length(conv.pts)
asv <- list()
rsv <- list()
ess.asv <- list()
ess.rsv <- list()
for (r in 1:rep){
print(paste("Sampling for rep =", r))
asv.samp <- array(0, dim = c(p, p, l))
rsv.samp <- array(0, dim = c(p, p, l))
ess.asv.samp <- rep(0, l)
ess.rsv.samp <- rep(0, l)
master.chain <- array(0, dim = c(max, p, m))
for (k in 1:m){
print(paste("Sampling chain - ", k))
master.chain[,,k] <- markov.chain(A, B, C, max, start[k,])
}
for (j in 1:l){
nsim <- conv.pts[j]
chain <- master.chain[1:nsim,,]
sve <- array(0, dim = c(p,p,m))
rsve <- array(0, dim = c(p,p,m))
smpl.cov <- array(0, dim = c(p,p,m))
b <- rep(0,m)
for (k in 1:m){
b[k] <- batchSize(chain[,,k], method = "bartlett")
smpl.cov[,,k] <- cov(chain[,,k])
}
b.avg <- ceiling(mean(b))
global.mean <- apply(chain,2,mean)
for (k in 1:m){
chain.cen.loc <- scale(chain[,,k], scale = FALSE)  ## X_st - bar(X)_s
sve[,,k] <- mSVEfft(A = chain.cen.loc, b = b.avg)
chain.cen <- scale(chain[,,k], center = global.mean, scale =FALSE)
rsve[,,k] <- mSVEfft(A = chain.cen, b = b.avg)
}
asv.samp[,,j] <- apply(sve, c(1,2), mean)
rsv.samp[,,j] <- apply(rsve, c(1,2), mean)
lambda.rep <- apply(smpl.cov, c(1,2), mean)
ess.asv.samp[j] <- (det(lambda.rep)/det(asv.samp[,,j]))^(1/p)
ess.rsv.samp[j] <- (det(lambda.rep)/det(rsv.samp[,,j]))^(1/p)
}
asv[[r]] <- asv.samp
rsv[[r]] <- rsv.samp
ess.asv[[r]] <- ess.asv.samp
ess.rsv[[r]] <- ess.rsv.samp
save(asv, rsv, ess.asv, ess.rsv,
file = paste(paste("Out/", A, B, C, "conv_data_m", sep = "_"), m, "_min", min, "_max", max, ".Rdata", sep = ""))
}
}
A <- 1
B <- 3
C <- 8
m = 2
check.pts <- c(1e3, 2e3, 5e3, 1e4, 2e4, 5e4, 1e5)
freq <- 1
Sys.time(create.output(A, B, C, m, check.pts, freq, c.prob))
t1 <- Sys.time()
create.output(A, B, C, m, check.pts, freq, c.prob)
t2 <- Sys.time()
print(t2-t1)
7800/60
130/60
load(file = paste(paste("Out/", A, B, C, "/out_check.pts", A, B, C, "freq", sep = "_"), freq, ".Rdata", sep=""))
asv.coverage
min <- 5e2
max <- 1e5
step <- 5e2
rep <- 1
print("Carrying out simulations for running plots of ASV and RSV in the range(1e3, 1e5")
t1 <- Sys.time()
convergence(min, max, step, A, B, C, m, rep)
t2 <- Sys.time()
print(t2-t1)
###########
1.519 * 50
76/60
################################################################
##This code is responsible for simulating and storing R objects
##that are later used for plotting figures and making tables.
################################################################
set.seed(1)
library(cubature)
library(Rcpp)
library(RcppArmadillo)
library(fftwtools)
library(mcmcse)
source("functions.R")
sourceCpp("lag.cpp")
############################################################
##creates freq=1000 replications of ASV and RSV for each value of nsim from check.pts
############################################################
create.output <- function(A, B, C, m, check.pts, freq, c.prob){
p <- 2
start <- matrix(0, nrow = m, ncol = 2)  #only depends on C
T.mean <- true.mean(A, B, C)
for(i in 1:floor(m/2)){
start[i,] <- c(0, C*(2^(2-i)))
start[m-i+1,] <- c(C*(2^(2-i)), 0)
}
asv.samples <- list()
gsv.samples <- list()
asv.coverage <- list()
gsv.coverage <- list()
for (i in 1:length(check.pts)){
asv.samples[[i]] <- array(0, dim = c(p,p,freq))
gsv.samples[[i]] <- array(0, dim = c(p,p,freq))
asv.coverage[[i]] <- rep(0, freq)
gsv.coverage[[i]] <- rep(0, freq)
}
for (j in 1:freq){
if(j %% (freq/1000) == 0) print(paste("Percentage completion: ", round(j/freq*100, 2)))
master.chain <- array(0, dim = c(max(check.pts), p, m))
for (k in 1:m)
master.chain[,,k] <- markov.chain(A, B, C, max(check.pts), start[k,])
for (i in 1:length(check.pts))
{
nsim <- check.pts[i]
critical <- ((nsim*m - 1)*p/(nsim*m  - p))*qf(.95, df1 = p, df2 = (nsim*m-p))
chains <- master.chain[1:nsim,,]
sve <- array(0, dim = c(p,p,m))
rsve <- array(0, dim = c(p,p,m))
b <- rep(0,m)
for (k in 1:m){
b[k] <- batchSize(chains[,,k], method = "bartlett")
}
b.avg <- ceiling(mean(b))
global.mean <- apply(chains, 2, mean)
for (k in 1:m){
chain.cen.loc <- scale(chains[,,k], scale = FALSE)  ## X_st - bar(X)_s
sve[,,k] <- mSVEfft(A = chain.cen.loc, b = b.avg)
chain.cen <- scale(chains[,,k], center = global.mean, scale =FALSE)
rsve[,,k] <- mSVEfft(A = chain.cen, b = b.avg)
}
asv.samples[[i]][,,j] <- apply(sve, c(1,2), mean)
gsv.samples[[i]][,,j] <- apply(rsve, c(1,2), mean)
chi.sq.asv <- t2.stat(global.mean, T.mean, asv.samples[[i]][,,j], nsim*m)
chi.sq.gsv <- t2.stat(global.mean, T.mean, gsv.samples[[i]][,,j], nsim*m)
if (chi.sq.asv <= critical) {asv.coverage[[i]][j]=1}
if (chi.sq.gsv <= critical) {gsv.coverage[[i]][j]=1}
}
}
save(asv.samples, gsv.samples, asv.coverage, gsv.coverage,
file = paste(paste("Out/", A, B, C, "/out_check.pts", A, B, C, "freq", sep = "_"), freq, ".Rdata", sep=""))
}
##################################################
#function for storing convergence plots data
##################################################
convergence <- function(min, max, step, A, B, C, m, rep){
p <- 2
start <- matrix(0, nrow = m, ncol = 2)  #only depends on C
for(i in 1:floor(m/2)){
start[i,] <- c(0, C*(2^(2-i)))
start[m-i+1,] <- c(C*(2^(2-i)), 0)
}
conv.pts <- seq(min, max, step)
l <- length(conv.pts)
asv <- list()
rsv <- list()
ess.asv <- list()
ess.rsv <- list()
for (r in 1:rep){
print(paste("Sampling for rep =", r))
asv.samp <- array(0, dim = c(p, p, l))
rsv.samp <- array(0, dim = c(p, p, l))
ess.asv.samp <- rep(0, l)
ess.rsv.samp <- rep(0, l)
master.chain <- array(0, dim = c(max, p, m))
for (k in 1:m){
print(paste("Sampling chain - ", k))
master.chain[,,k] <- markov.chain(A, B, C, max, start[k,])
}
for (j in 1:l){
nsim <- conv.pts[j]
chain <- master.chain[1:nsim,,]
sve <- array(0, dim = c(p,p,m))
rsve <- array(0, dim = c(p,p,m))
smpl.cov <- array(0, dim = c(p,p,m))
b <- rep(0,m)
for (k in 1:m){
b[k] <- batchSize(chain[,,k], method = "bartlett")
smpl.cov[,,k] <- cov(chain[,,k])
}
b.avg <- ceiling(mean(b))
global.mean <- apply(chain,2,mean)
for (k in 1:m){
chain.cen.loc <- scale(chain[,,k], scale = FALSE)  ## X_st - bar(X)_s
sve[,,k] <- mSVEfft(A = chain.cen.loc, b = b.avg)
chain.cen <- scale(chain[,,k], center = global.mean, scale =FALSE)
rsve[,,k] <- mSVEfft(A = chain.cen, b = b.avg)
}
asv.samp[,,j] <- apply(sve, c(1,2), mean)
rsv.samp[,,j] <- apply(rsve, c(1,2), mean)
lambda.rep <- apply(smpl.cov, c(1,2), mean)
ess.asv.samp[j] <- (det(lambda.rep)/det(asv.samp[,,j]))^(1/p)
ess.rsv.samp[j] <- (det(lambda.rep)/det(rsv.samp[,,j]))^(1/p)
}
asv[[r]] <- asv.samp
rsv[[r]] <- rsv.samp
ess.asv[[r]] <- ess.asv.samp
ess.rsv[[r]] <- ess.rsv.samp
save(asv, rsv, ess.asv, ess.rsv,
file = paste(paste("Out/", A, B, C, "/conv_data_m", sep = "_"), m, "_min", min, "_max", max, ".Rdata", sep = ""))
}
}
################################################################
##This code is responsible for simulating and storing R objects
##that are later used for plotting figures and making tables.
################################################################
set.seed(1)
library(cubature)
library(Rcpp)
library(RcppArmadillo)
library(fftwtools)
library(mcmcse)
source("functions.R")
sourceCpp("lag.cpp")
############################################################
##creates freq=1000 replications of ASV and RSV for each value of nsim from check.pts
############################################################
create.output <- function(A, B, C, m, check.pts, freq, c.prob){
p <- 2
start <- matrix(0, nrow = m, ncol = 2)  #only depends on C
T.mean <- true.mean(A, B, C)
for(i in 1:floor(m/2)){
start[i,] <- c(0, C*(2^(2-i)))
start[m-i+1,] <- c(C*(2^(2-i)), 0)
}
asv.samples <- list()
gsv.samples <- list()
asv.coverage <- list()
gsv.coverage <- list()
for (i in 1:length(check.pts)){
asv.samples[[i]] <- array(0, dim = c(p,p,freq))
gsv.samples[[i]] <- array(0, dim = c(p,p,freq))
asv.coverage[[i]] <- rep(0, freq)
gsv.coverage[[i]] <- rep(0, freq)
}
for (j in 1:freq){
if(j %% (freq/1000) == 0) print(paste("Percentage completion: ", round(j/freq*100, 2)))
master.chain <- array(0, dim = c(max(check.pts), p, m))
for (k in 1:m)
master.chain[,,k] <- markov.chain(A, B, C, max(check.pts), start[k,])
for (i in 1:length(check.pts))
{
nsim <- check.pts[i]
critical <- ((nsim*m - 1)*p/(nsim*m  - p))*qf(.95, df1 = p, df2 = (nsim*m-p))
chains <- master.chain[1:nsim,,]
sve <- array(0, dim = c(p,p,m))
rsve <- array(0, dim = c(p,p,m))
b <- rep(0,m)
for (k in 1:m){
b[k] <- batchSize(chains[,,k], method = "bartlett")
}
b.avg <- ceiling(mean(b))
global.mean <- apply(chains, 2, mean)
for (k in 1:m){
chain.cen.loc <- scale(chains[,,k], scale = FALSE)  ## X_st - bar(X)_s
sve[,,k] <- mSVEfft(A = chain.cen.loc, b = b.avg)
chain.cen <- scale(chains[,,k], center = global.mean, scale =FALSE)
rsve[,,k] <- mSVEfft(A = chain.cen, b = b.avg)
}
asv.samples[[i]][,,j] <- apply(sve, c(1,2), mean)
gsv.samples[[i]][,,j] <- apply(rsve, c(1,2), mean)
chi.sq.asv <- t2.stat(global.mean, T.mean, asv.samples[[i]][,,j], nsim*m)
chi.sq.gsv <- t2.stat(global.mean, T.mean, gsv.samples[[i]][,,j], nsim*m)
if (chi.sq.asv <= critical) {asv.coverage[[i]][j]=1}
if (chi.sq.gsv <= critical) {gsv.coverage[[i]][j]=1}
}
}
save(asv.samples, gsv.samples, asv.coverage, gsv.coverage,
file = paste(paste("Out/", A, B, C, "/out_check.pts", A, B, C, "freq", sep = "_"), freq, ".Rdata", sep=""))
}
##################################################
#function for storing convergence plots data
##################################################
convergence <- function(min, max, step, A, B, C, m, rep){
p <- 2
start <- matrix(0, nrow = m, ncol = 2)  #only depends on C
for(i in 1:floor(m/2)){
start[i,] <- c(0, C*(2^(2-i)))
start[m-i+1,] <- c(C*(2^(2-i)), 0)
}
conv.pts <- seq(min, max, step)
l <- length(conv.pts)
asv <- list()
rsv <- list()
ess.asv <- list()
ess.rsv <- list()
for (r in 1:rep){
print(paste("Sampling for rep =", r))
asv.samp <- array(0, dim = c(p, p, l))
rsv.samp <- array(0, dim = c(p, p, l))
ess.asv.samp <- rep(0, l)
ess.rsv.samp <- rep(0, l)
master.chain <- array(0, dim = c(max, p, m))
for (k in 1:m){
print(paste("Sampling chain - ", k))
master.chain[,,k] <- markov.chain(A, B, C, max, start[k,])
}
for (j in 1:l){
nsim <- conv.pts[j]
chain <- master.chain[1:nsim,,]
sve <- array(0, dim = c(p,p,m))
rsve <- array(0, dim = c(p,p,m))
smpl.cov <- array(0, dim = c(p,p,m))
b <- rep(0,m)
for (k in 1:m){
b[k] <- batchSize(chain[,,k], method = "bartlett")
smpl.cov[,,k] <- cov(chain[,,k])
}
b.avg <- ceiling(mean(b))
global.mean <- apply(chain,2,mean)
for (k in 1:m){
chain.cen.loc <- scale(chain[,,k], scale = FALSE)  ## X_st - bar(X)_s
sve[,,k] <- mSVEfft(A = chain.cen.loc, b = b.avg)
chain.cen <- scale(chain[,,k], center = global.mean, scale =FALSE)
rsve[,,k] <- mSVEfft(A = chain.cen, b = b.avg)
}
asv.samp[,,j] <- apply(sve, c(1,2), mean)
rsv.samp[,,j] <- apply(rsve, c(1,2), mean)
lambda.rep <- apply(smpl.cov, c(1,2), mean)
ess.asv.samp[j] <- (det(lambda.rep)/det(asv.samp[,,j]))^(1/p)
ess.rsv.samp[j] <- (det(lambda.rep)/det(rsv.samp[,,j]))^(1/p)
}
asv[[r]] <- asv.samp
rsv[[r]] <- rsv.samp
ess.asv[[r]] <- ess.asv.samp
ess.rsv[[r]] <- ess.rsv.samp
save(asv, rsv, ess.asv, ess.rsv,
file = paste(paste("Out/", A, B, C, "/conv_data_m", sep = "_"), m, "_min", min, "_max", max, ".Rdata", sep = ""))
}
}
A <- 1
B <- 3
C <- 8
m = 2
check.pts <- c(1e3, 5e3, 1e4, 2e4, 5e4, 1e5)
freq <- 1000
rep <- 50
c.prob <- .95
min <- 5e2
max <- 1e5
step <- 5e2
conv.pts <- seq(min, max, step)
print("Carrying out 1000 repititions for each value of nsim in check.pts")
t1 <- Sys.time()
create.output(A, B, C, m, check.pts, freq, c.prob)
t2 <- Sys.time()
print(t2-t1)
#### Five chains
m = 5
print("Carrying out 1000 repititions for each value of nsim in check.pts")
t1 <- Sys.time()
create.output(A, B, C, m, check.pts, freq, c.prob)
t2 <- Sys.time()
print(t2-t1)
print("Carrying out simulations for running plots of ASV and RSV in the range(1e3, 1e5")
t1 <- Sys.time()
convergence(min, max, step, A, B, C, m, rep)
t2 <- Sys.time()
print(t2-t1)
setwd("~/GitHub/Replicated-Spectral-Variance-Estimator/SensorNetwork")
set.seed(1)
library(cubature)
library(graphics)
library(pracma)
library(Rcpp)
library(RcppArmadillo)
library(fftwtools)
library(mcmcse)
library(stats)
library(plotly)
sourceCpp("lag.cpp")
source("functions.R")
###################################################
### Data and model parameters
######################################################################
# Observation indicators from the fifth sensor (1st column) to the first four sensors
# and those from the sixth sensor (2nd column) to the first four sensors.
Ob <- matrix(c(1, 0, 1, 0, 1, 0, 1, 0), ncol = 2)
# Observation indicators among the first four sensors.
Os <- matrix(c(0, 0, 0, 1,
0, 0, 1, 1,
0, 1, 0, 0,
1, 1, 0, 0), ncol = 4)
# Each row indicates the location of the known sensors (5th and 6th).
Xb <- matrix(c(0.5, 0.3, 0.3, 0.7), ncol = 2)
# Each row indicates the location of the unknown sensors (1st, 2nd, 3rd, and 4th).
Xs <- matrix(c(0.5748, 0.0991, 0.2578, 0.8546,
0.9069, 0.3651, 0.1350, 0.0392), ncol = 2)
# The observed distances from the fifth sensor (1st column) to the first four sensors
# and those from the sixth sensor (2nd column) to the first four sensors.
Yb <- matrix(c(0.6103, 0, 0.2995, 0,
0.3631, 0, 0.5656, 0), ncol = 2)
# Observed distances among the first four sensors.
Ys <- matrix(c(0, 0, 0, 0.9266,
0, 0, 0.2970, 0.8524,
0, 0.2970, 0, 0,
0.9266, 0.8524, 0, 0), ncol = 4)
m <- 5
start <- rbind(runif(n=8, min=-0.3, max=0), runif(n=8, min=0.7, max=1))
aux <- rbind(runif(n=8, min=-0.3, max=0), runif(n=8, min=0.7, max=1))
j.scale <- rep(1,.08, 4)
check.pts <- c(5e3, 1e4, 5e4, 1e5)
r <- length(check.pts)
freq <- 1e2
c.prob <- .95
min <- 500
max <- 2e5
step <- 500
conv.pts <- seq(min, max, step)
p <- 8
load(file = paste("Out/conv_data_m", m, "_min", min, "_max", max, ".Rdata", sep = ""))
##
a <- lapply(ess.asv, log)
r <- lapply(ess.rsv, log)
se.a <- 2*apply(Reduce("rbind", a), 2, sd)/sqrt(length(a))
se.r <- 2*apply(Reduce("rbind", r), 2, sd)/sqrt(length(r))
a <- Reduce("+", a)/length(ess.asv)
r <- Reduce("+", r)/length(ess.rsv)
plot(conv.pts, a, type = "l", col = "darkorange", main = "", xlab = "Simulation size", ylab = "log(ESS/mn)", ylim = range(a, r, log(minESS(p, alpha = .1, eps = .1)/(m*conv.pts))), lwd = 2)
lines(conv.pts, r, col = "royalblue", lwd = 2)
segments(x0 = conv.pts, y0 = (a - se.a), y1 = (a + se.a), col = adjustcolor("darkorange", alpha.f = .50))
segments(x0 = conv.pts, y0 = (r - se.r), y1 = (r + se.r), col = adjustcolor("royalblue", alpha.f = .50))
lines(conv.pts, log(minESS(p, alpha = .1, eps = 0.1)/(m*conv.pts)), col = "green3", lwd=2)
legend("topright", legend=c("A-SVE", "G-SVE"),col=c("darkorange", "royalblue"), lty=1, cex=1.2, lwd=2)
setwd("~/GitHub/Replicated-Spectral-Variance-Estimator/VAR-1")
set.seed(1)
library(fields)
library(graphics)
library(Rcpp)
library(RcppArmadillo)
library(fftwtools)
library(mcmcse)
library(stats)
sourceCpp("lag.cpp")
source("functions.R")
###############################################
##### Model parameters####################
#########################################
m <- 5
p <- 2
omega <- diag(p)
for (i in 1:(p-1)){
for (j in 1:(p-i)){
omega[j, j+i] <- .9^i
omega[j+i, j] <- .9^i
}
}
phi <- diag(c(.999, .001))
dummy <- matrix(1:p^2, nrow = p, ncol = p)
dummy <- qr.Q(qr(dummy))
phi <- dummy %*% phi %*% t(dummy)
############3Simuation settings###########
target <- target.sigma(phi, omega)
truth <- true.sigma(phi, var = target)
check.pts <- c(5e2, 1e3, 5e3, 1e4, 5e4, 1e5)
rep <- 50
freq <- 1000
min <- 5e2
max <- 5e4
step <- 500
conv.pts <- seq(min, max, step)
#
load(file = paste("Out/conv_data_min", min, "_max", max, ".Rdata", sep = ""))
a <- lapply(ess.asv, log)
r <- lapply(ess.rsv, log)
se.a <- 2*apply(Reduce("rbind", a), 2, sd)/sqrt(length(a))
se.r <- 2*apply(Reduce("rbind", r), 2, sd)/sqrt(length(r))
a <- Reduce("+", a)/length(ess.asv)
r <- Reduce("+", r)/length(ess.rsv)
plot(conv.pts, a, type = "l", col = "darkorange", main = "", xlab = "Simulation size", ylab = "log(ESS/mn)", ylim = range(a, r, log(minESS(p)/(m*conv.pts))), lwd = 2)
lines(conv.pts, r, col = "royalblue", lwd = 2)
segments(x0 = conv.pts, y0 = (a - se.a), y1 = (a + se.a), col = adjustcolor("darkorange", alpha.f = .50))
segments(x0 = conv.pts, y0 = (r - se.r), y1 = (r + se.r), col = adjustcolor("royalblue", alpha.f = .50))
lines(conv.pts, log(minESS(p)/(m*conv.pts)), col = "pink")
abline(h = log((det(target)/det(truth))^(1/p)), col = "green3", lwd = 2)
lines(conv.pts, log(minESS(p)/(m*conv.pts)), col = "pink", lwd=2)
abline(h = log((det(target)/det(truth))^(1/p)), col = "green3", lwd = 2)
legend("topright", legend=c("A-SVE", "G-SVE", "Truth"),col=c("darkorange", "royalblue", "green3"), lty=1, cex=1, lwd = 2)
plot(conv.pts, a, type = "l", col = "darkorange", main = "", xlab = "Simulation size", ylab = "log(ESS/mn)", ylim = range(a, r, log(minESS(p, alpha=.1, eps=.1)/(m*conv.pts))), lwd = 2)
lines(conv.pts, r, col = "royalblue", lwd = 2)
segments(x0 = conv.pts, y0 = (a - se.a), y1 = (a + se.a), col = adjustcolor("darkorange", alpha.f = .50))
segments(x0 = conv.pts, y0 = (r - se.r), y1 = (r + se.r), col = adjustcolor("royalblue", alpha.f = .50))
lines(conv.pts, log(minESS(p, alpha=.1, eps=.1)/(m*conv.pts)), col = "pink", lwd=2)
abline(h = log((det(target)/det(truth))^(1/p)), col = "green3", lwd = 2)
legend("topright", legend=c("A-SVE", "G-SVE", "Truth"),col=c("darkorange", "royalblue", "green3"), lty=1, cex=1, lwd = 2)
ess.asv
a
a <- lapply(ess.asv, log)
a
a=ess.asv
r=ess.rsv
se.a <- 2*apply(Reduce("rbind", a), 2, sd)/sqrt(length(a))
se.r <- 2*apply(Reduce("rbind", r), 2, sd)/sqrt(length(r))
a <- Reduce("+", a)/length(ess.asv)
r <- Reduce("+", r)/length(ess.rsv)
plot(conv.pts, a, type = "l", col = "darkorange", main = "", xlab = "Simulation size", ylab = "log(ESS/mn)", ylim = range(a, r, (minESS(p, alpha=.1, eps=.1)/(m*conv.pts))), lwd = 2)
lines(conv.pts, r, col = "royalblue", lwd = 2)
segments(x0 = conv.pts, y0 = (a - se.a), y1 = (a + se.a), col = adjustcolor("darkorange", alpha.f = .50))
segments(x0 = conv.pts, y0 = (r - se.r), y1 = (r + se.r), col = adjustcolor("royalblue", alpha.f = .50))
lines(conv.pts, log(minESS(p, alpha=.1, eps=.1)/(m*conv.pts)), col = "pink", lwd=2)
lines(conv.pts, (minESS(p, alpha=.1, eps=.1)/(m*conv.pts)), col = "pink", lwd=2)
plot(conv.pts, a, type = "l", col = "darkorange", main = "", xlab = "Simulation size", ylab = "log(ESS/mn)", ylim = range(a, r, (minESS(p)/(m*conv.pts))), lwd = 2)
lines(conv.pts, r, col = "royalblue", lwd = 2)
segments(x0 = conv.pts, y0 = (a - se.a), y1 = (a + se.a), col = adjustcolor("darkorange", alpha.f = .50))
segments(x0 = conv.pts, y0 = (r - se.r), y1 = (r + se.r), col = adjustcolor("royalblue", alpha.f = .50))
lines(conv.pts, (minESS(p)/(m*conv.pts)), col = "pink", lwd=2)
abline(h = log((det(target)/det(truth))^(1/p)), col = "green3", lwd = 2)
legend("topright", legend=c("A-SVE", "G-SVE", "Truth"),col=c("darkorange", "royalblue", "green3"), lty=1, cex=1, lwd = 2)
p
