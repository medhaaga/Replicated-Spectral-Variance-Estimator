}
}
return(acf.list)
}
if(is.null(chains) && avg == FALSE)
stop("Nothing to return/plot")
for (i in 1:length(x)){
if(!is.numeric(x[[i]]))
stop("'mc.chain' must be numeric")
}
n <- as.integer(nrow(x[[1]]))
p <- as.integer(ncol(x[[1]]))
if (is.na(n) || is.na(p))
stop("no. of samples and dim must be integer")
if(is.null(component))
stop("'component' parameter missing")
if (is.null(lag.max))
lag.max <- floor(10 * (log10(n)))
lag.max <- as.integer(min(lag.max, n - 1L))
if (is.na(lag.max) || lag.max < 0)
stop("'lag.max' must be at least 0")
m <- length(x) # number of chains
mc.chains <- array(0, dim = c(n, m))
for (i in 1:m)
mc.chains[,i] <- x[[i]][, component]
################## centering ######################
if(is.null(mean) || mean == "global"){
center = mean(mc.chains)
mc.chains <- mc.chains - center
} else if (mean == "local"){
mc.chains <- scale(mc.chains, scale = FALSE)
} else {
if(!is.numeric(mean) || length(mean) != p)
stop("'mean' is not numeric or of correct dimensions.")
mc.chains <- apply(mc.chains, 1, '-', mean)
}
#######################################################
acf.list <- list()
if (avg)
{
acf.list[[1]] <- acf(mc.chains[,1], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf <- acf.list[[1]]
for (i in 2:m){
acf.list[[i]] <- acf(mc.chains[,i], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf$acf <- G.acf$acf + acf.list[[i]]$acf
}
G.acf$acf <- G.acf$acf/m
acf.list[[m+1]] <- G.acf
if (graph)
{
if(!is.null(chains))
{
plot(G.acf, type = "l", main = "")
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (i in 1:length(chains)){
j <- chains[i]
par(new = TRUE)
plot(acf.list[[j]], col = i+1, type = "l", main = "")
}
}  else
plot(G.acf)
}
} else
{
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (j in 1:length(chains))
acf.list[[j]] <- acf(mc.chains[,chains[j]], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
if(graph)
{
if (length(chains) == 1)
plot(acf.list[[1]]) else
{
for (i in 1:length(chains))
{
par(new = TRUE)
plot(acf.list[[i]], type = "l", col = i)
}
}
}
}
return(acf.list)
globalACF <- function(x, chains = NULL, component = NULL, lag.max = NULL, mean = NULL
type = c("covariance", "correlation"), avg = TRUE, graph = TRUE)
{
if(is.null(chains) && avg == FALSE)
stop("Nothing to return/plot")
for (i in 1:length(x)){
if(!is.numeric(x[[i]]))
stop("'mc.chain' must be numeric")
}
n <- as.integer(nrow(x[[1]]))
p <- as.integer(ncol(x[[1]]))
if (is.na(n) || is.na(p))
stop("no. of samples and dim must be integer")
if(is.null(component))
stop("'component' parameter missing")
if (is.null(lag.max))
lag.max <- floor(10 * (log10(n)))
lag.max <- as.integer(min(lag.max, n - 1L))
if (is.na(lag.max) || lag.max < 0)
stop("'lag.max' must be at least 0")
m <- length(x) # number of chains
mc.chains <- array(0, dim = c(n, m))
for (i in 1:m)
mc.chains[,i] <- x[[i]][, component]
################## centering ######################
if(is.null(mean) || mean == "global"){
center = mean(mc.chains)
mc.chains <- mc.chains - center
} else if (mean == "local"){
mc.chains <- scale(mc.chains, scale = FALSE)
} else {
if(!is.numeric(mean) || length(mean) != p)
stop("'mean' is not numeric or of correct dimensions.")
mc.chains <- apply(mc.chains, 1, '-', mean)
}
#######################################################
acf.list <- list()
if (avg)
{
acf.list[[1]] <- acf(mc.chains[,1], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf <- acf.list[[1]]
for (i in 2:m){
acf.list[[i]] <- acf(mc.chains[,i], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf$acf <- G.acf$acf + acf.list[[i]]$acf
}
G.acf$acf <- G.acf$acf/m
acf.list[[m+1]] <- G.acf
if (graph)
{
if(!is.null(chains))
{
plot(G.acf, type = "l", main = "")
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (i in 1:length(chains)){
j <- chains[i]
par(new = TRUE)
plot(acf.list[[j]], col = i+1, type = "l", main = "")
}
}  else
plot(G.acf)
}
} else
{
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (j in 1:length(chains))
acf.list[[j]] <- acf(mc.chains[,chains[j]], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
if(graph)
{
if (length(chains) == 1)
plot(acf.list[[1]]) else
{
for (i in 1:length(chains))
{
par(new = TRUE)
plot(acf.list[[i]], type = "l", col = i)
}
}
}
}
return(acf.list)
}
globalACF <- function(x, chains = NULL, component = NULL, lag.max = NULL, mean = NULL
type = c("covariance", "correlation"), avg = TRUE, graph = TRUE)
{
if(is.null(chains) && avg == FALSE)
stop("Nothing to return/plot")
for (i in 1:length(x)){
if(!is.numeric(x[[i]]))
stop("'mc.chain' must be numeric")
}
n <- as.integer(nrow(x[[1]]))
p <- as.integer(ncol(x[[1]]))
if (is.na(n) || is.na(p))
stop("no. of samples and dim must be integer")
if(is.null(component))
stop("'component' parameter missing")
if (is.null(lag.max))
lag.max <- floor(10 * (log10(n)))
lag.max <- as.integer(min(lag.max, n - 1L))
if (is.na(lag.max) || lag.max < 0)
stop("'lag.max' must be at least 0")
m <- length(x) # number of chains
mc.chains <- array(0, dim = c(n, m))
for (i in 1:m)
mc.chains[,i] <- x[[i]][, component]
################## centering ######################
if(is.null(mean) || mean == "global"){
center = mean(mc.chains)
mc.chains <- mc.chains - center
} else if (mean == "local"){
mc.chains <- scale(mc.chains, scale = FALSE)
} else {
if(!is.numeric(mean) || length(mean) != p)
stop("'mean' is not numeric or of correct dimensions.")
mc.chains <- apply(mc.chains, 1, '-', mean)
}
#######################################################
acf.list <- list()
if (avg)
{
acf.list[[1]] <- acf(mc.chains[,1], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf <- acf.list[[1]]
for (i in 2:m){
acf.list[[i]] <- acf(mc.chains[,i], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf$acf <- G.acf$acf + acf.list[[i]]$acf
}
G.acf$acf <- G.acf$acf/m
acf.list[[m+1]] <- G.acf
if (graph)
{
if(!is.null(chains))
{
plot(G.acf, type = "l", main = "")
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (i in 1:length(chains)){
j <- chains[i]
par(new = TRUE)
plot(acf.list[[j]], col = i+1, type = "l", main = "")
}
}  else
plot(G.acf)
}
} else
{
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (j in 1:length(chains))
acf.list[[j]] <- acf(mc.chains[,chains[j]], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
if(graph)
{
if (length(chains) == 1)
plot(acf.list[[1]]) else
{
for (i in 1:length(chains))
{
par(new = TRUE)
plot(acf.list[[i]], type = "l", col = i)
}
}
}
}
return(acf.list)
}
globalACF <- function(x, chains = NULL, component = NULL, lag.max = NULL, mean = NULL, type = c("covariance", "correlation"), avg = TRUE, graph = TRUE)
{
if(is.null(chains) && avg == FALSE)
stop("Nothing to return/plot")
for (i in 1:length(x)){
if(!is.numeric(x[[i]]))
stop("'mc.chain' must be numeric")
}
n <- as.integer(nrow(x[[1]]))
p <- as.integer(ncol(x[[1]]))
if (is.na(n) || is.na(p))
stop("no. of samples and dim must be integer")
if(is.null(component))
stop("'component' parameter missing")
if (is.null(lag.max))
lag.max <- floor(10 * (log10(n)))
lag.max <- as.integer(min(lag.max, n - 1L))
if (is.na(lag.max) || lag.max < 0)
stop("'lag.max' must be at least 0")
m <- length(x) # number of chains
mc.chains <- array(0, dim = c(n, m))
for (i in 1:m)
mc.chains[,i] <- x[[i]][, component]
################## centering ######################
if(is.null(mean) || mean == "global"){
center = mean(mc.chains)
mc.chains <- mc.chains - center
} else if (mean == "local"){
mc.chains <- scale(mc.chains, scale = FALSE)
} else {
if(!is.numeric(mean) || length(mean) != p)
stop("'mean' is not numeric or of correct dimensions.")
mc.chains <- apply(mc.chains, 1, '-', mean)
}
#######################################################
acf.list <- list()
if (avg)
{
acf.list[[1]] <- acf(mc.chains[,1], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf <- acf.list[[1]]
for (i in 2:m){
acf.list[[i]] <- acf(mc.chains[,i], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf$acf <- G.acf$acf + acf.list[[i]]$acf
}
G.acf$acf <- G.acf$acf/m
acf.list[[m+1]] <- G.acf
if (graph)
{
if(!is.null(chains))
{
plot(G.acf, type = "l", main = "")
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (i in 1:length(chains)){
j <- chains[i]
par(new = TRUE)
plot(acf.list[[j]], col = i+1, type = "l", main = "")
}
}  else
plot(G.acf)
}
} else
{
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (j in 1:length(chains))
acf.list[[j]] <- acf(mc.chains[,chains[j]], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
if(graph)
{
if (length(chains) == 1)
plot(acf.list[[1]]) else
{
for (i in 1:length(chains))
{
par(new = TRUE)
plot(acf.list[[i]], type = "l", col = i)
}
}
}
}
return(acf.list)
}
globalACF(x, component = 1, type = "correlation", lag.max = 5)
globalACF(x, component = 1, type = "correlation", lag.max = 5, avg = FALSE)
globalACF(x, component = 1, type = "correlation", lag.max = 5, chains = 0)
globalACF <- function(x, chains = NULL, component = NULL, lag.max = NULL, mean = NULL, type = c("covariance", "correlation"), avg = TRUE, graph = TRUE)
{
if(is.null(chains) && avg == FALSE)
stop("Nothing to return/plot")
for (i in 1:length(x)){
if(!is.numeric(x[[i]]))
stop("'mc.chain' must be numeric")
}
n <- as.integer(nrow(x[[1]]))
p <- as.integer(ncol(x[[1]]))
if (is.na(n) || is.na(p))
stop("no. of samples and dim must be integer")
if(is.null(component))
stop("'component' parameter missing")
if (is.null(lag.max))
lag.max <- floor(10 * (log10(n)))
lag.max <- as.integer(min(lag.max, n - 1L))
if (is.na(lag.max) || lag.max < 0)
stop("'lag.max' must be at least 0")
m <- length(x) # number of chains
mc.chains <- array(0, dim = c(n, m))
for (i in 1:m)
mc.chains[,i] <- x[[i]][, component]
################## centering ######################
if(is.null(mean) || mean == "global"){
center = mean(mc.chains)
mc.chains <- mc.chains - center
} else if (mean == "local"){
mc.chains <- scale(mc.chains, scale = FALSE)
} else {
if(!is.numeric(mean) || length(mean) != p)
stop("'mean' is not numeric or of correct dimensions.")
mc.chains <- apply(mc.chains, 1, '-', mean)
}
#######################################################
acf.list <- list()
if (avg)
{
acf.list[[1]] <- acf(mc.chains[,1], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf <- acf.list[[1]]
for (i in 2:m){
acf.list[[i]] <- acf(mc.chains[,i], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf$acf <- G.acf$acf + acf.list[[i]]$acf
}
G.acf$acf <- G.acf$acf/m
if (graph)
{
if(!is.null(chains))
{
plot(G.acf, type = "l", main = "")
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (i in 1:length(chains)){
j <- chains[i]
par(new = TRUE)
plot(acf.list[[j]], col = i+1, type = "l", main = "")
}
}  else
plot(G.acf)
}
} else
{
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (j in 1:length(chains))
acf.list[[j]] <- acf(mc.chains[,chains[j]], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
if(graph)
{
if (length(chains) == 1)
plot(acf.list[[1]]) else
{
for (i in 1:length(chains))
{
par(new = TRUE)
plot(acf.list[[i]], type = "l", col = i)
}
}
}
}
if(avf)
return (list("G-ACF" = G.ACF, "chainsACF" = acf.list)) else
return(acf.list)
}
globalACF(x, component = 1, lag.max = 5, avg = TRUE, type = "correlation", chains = 0)
G-ACF <- acf()
G-ACF <- list()
attr(G-ACF, "class") <- "acf"
G-ACF <- list()
G_ACF <- list()
attr(G_ACF, "class") <- "acf"
G_ACF
globalACF <- function(x, chains = NULL, component = NULL, lag.max = NULL, mean = NULL, type = c("covariance", "correlation"), avg = TRUE, graph = TRUE)
{
if(is.null(chains) && avg == FALSE)
stop("Nothing to return/plot")
for (i in 1:length(x)){
if(!is.numeric(x[[i]]))
stop("'mc.chain' must be numeric")
}
n <- as.integer(nrow(x[[1]]))
p <- as.integer(ncol(x[[1]]))
if (is.na(n) || is.na(p))
stop("no. of samples and dim must be integer")
if(is.null(component))
stop("'component' parameter missing")
if (is.null(lag.max))
lag.max <- floor(10 * (log10(n)))
lag.max <- as.integer(min(lag.max, n - 1L))
if (is.na(lag.max) || lag.max < 0)
stop("'lag.max' must be at least 0")
m <- length(x) # number of chains
mc.chains <- array(0, dim = c(n, m))
for (i in 1:m)
mc.chains[,i] <- x[[i]][, component]
################## centering ######################
if(is.null(mean) || mean == "global"){
center = mean(mc.chains)
mc.chains <- mc.chains - center
} else if (mean == "local"){
mc.chains <- scale(mc.chains, scale = FALSE)
} else {
if(!is.numeric(mean) || length(mean) != p)
stop("'mean' is not numeric or of correct dimensions.")
mc.chains <- apply(mc.chains, 1, '-', mean)
}
#######################################################
acf.list <- list()
G.acf <- list()
attr(G.acf, "class") <- "acf"
if (avg)
{
acf.list[[1]] <- acf(mc.chains[,1], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf <- acf.list[[1]]
for (i in 2:m){
acf.list[[i]] <- acf(mc.chains[,i], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
G.acf$acf <- G.acf$acf + acf.list[[i]]$acf
}
G.acf$acf <- G.acf$acf/m
if (graph)
{
if(!is.null(chains))
{
plot(G.acf, type = "l", main = "")
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (i in 1:length(chains)){
j <- chains[i]
par(new = TRUE)
plot(acf.list[[j]], col = i+1, type = "l", main = "")
}
}  else
plot(G.acf)
}
} else
{
if (length(chains) == 1 && chains == 0)
chains <- seq(1,m,1)
for (j in 1:length(chains))
acf.list[[j]] <- acf(mc.chains[,chains[j]], type = type, plot = FALSE, demean = FALSE, lag.max = lag.max)
if(graph)
{
if (length(chains) == 1)
plot(acf.list[[1]]) else
{
for (i in 1:length(chains))
{
par(new = TRUE)
plot(acf.list[[i]], type = "l", col = i)
}
}
}
}
if(avf)
return (list("G-ACF" = G.acf, "chainsACF" = acf.list)) else
return(acf.list)
}
globalACF(x, component = 1, lag.max = 5, avg = TRUE, type = "correlation", chains = 0)
globalACF(x, component = 1, lag.max = 5, avg = TRUE, type = "correlation", chains = c(2,4))
